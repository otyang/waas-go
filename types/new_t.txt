package types

import (
	"errors"
	"strings"
	"sync"
	"time"

	"github.com/shopspring/decimal"
)

// Wallet holds funds for a customer with thread-safe operations
type Wallet struct {
	ID                string          `json:"id"`                     // Unique ID
	CustomerID        string          `json:"customerId"`             // Owner ID
	AvailableBalance  decimal.Decimal `json:"availableBalance"`       // Spendable amount
	LienBalance       decimal.Decimal `json:"lienBalance"`            // Reserved amount
	CurrencyCode      string          `json:"currencyCode"`           // Currency type (USD, EUR etc.)
	IsClosed          bool            `json:"isClosed"`               // Closed flag
	Frozen            bool            `json:"frozen"`                 // Frozen flag
	FreezeReason      string          `json:"freezeReason,omitempty"` //Freeze Reason
	FreezeInitiatedBy string          `json:"freezeInitiatedBy"`
	FrozenAt          time.Time       `json:"frozenAt"`
	CreatedAt         time.Time       `json:"createdAt"` // Creation time
	UpdatedAt         time.Time       `json:"updatedAt"` // Last update time
	VersionId         string          `json:"-"`         // For concurrency control
	mutex             sync.RWMutex    `json:"-"`         // Thread safety
}

// NewWallet creates and initializes a new Wallet instance
func NewWallet(customerID, currencyCode string) (*Wallet, error) {
	// Validate inputs
	if customerID == "" {
		return nil, errors.New("customer ID cannot be empty")
	}
	if currencyCode == "" {
		return nil, errors.New("currency code cannot be empty")
	}

	now := time.Now().UTC()

	wallet := &Wallet{
		ID:               GenerateID("wt_", 10), // Generate a new UUID
		CustomerID:       customerID,
		AvailableBalance: decimal.NewFromInt(0),
		LienBalance:      decimal.NewFromInt(0),
		CurrencyCode:     strings.ToUpper(currencyCode),
		IsClosed:         false,
		Frozen:           false,
		FreezeReason:     "",
		FrozenAt:         time.Time{}, // Zero time
		//	FreezeInitiatedBy: stringPtr(""),
		CreatedAt: now,
		UpdatedAt: now,
		VersionId: GenerateID("wtvid_", 15), // Initial version
		// mutex is zero-valued which is fine for sync.RWMutex
	}

	return wallet, nil
}

// CanBeDebited checks if wallet is in a state that allows debits
func (w *Wallet) CanBeDebited() error {
	if w.IsClosed {
		return ErrWalletClosed
	}
	if w.Frozen {
		return ErrWalletFrozen
	}
	return nil
}

// CanBeCredited checks if wallet is in a state that allows credits
func (w *Wallet) CanBeCredited() error {
	if w.IsClosed {
		return ErrWalletClosed
	}
	return nil
}

// TotalBalance returns sum of available and lien balances
func (w *Wallet) TotalBalance() decimal.Decimal {
	w.mutex.RLock()
	defer w.mutex.RUnlock()
	return w.AvailableBalance.Add(w.LienBalance)
}


 
 
// TransactionCategory defines the type of transaction being performed
type TransactionCategory string

const (
	CategoryDeposit    TransactionCategory = "DEPOSIT"    // Funds being added to wallet
	CategoryTransfer   TransactionCategory = "TRANSFER"   // Funds moving between wallets
	CategoryRefund     TransactionCategory = "REFUND"     // Funds being returned
	CategoryAdjustment TransactionCategory = "ADJUSTMENT" // Manual balance adjustment
	CategoryFee        TransactionCategory = "FEE"        // Transaction fee deduction
)

// TransactionType indicates the direction of funds movement
type TransactionType string

const (
	TypeCredit TransactionType = "CREDIT" // Funds being added
	TypeDebit  TransactionType = "DEBIT"  // Funds being deducted
)

// TransactionStatus represents the current state of a transaction
type TransactionStatus string

const (
	StatusCompleted TransactionStatus = "COMPLETED" // Successfully processed
	StatusFailed    TransactionStatus = "FAILED"    // Processing failed
	StatusPending   TransactionStatus = "PENDING"   // Awaiting processing
)

// TransactionHistory contains the complete record of a wallet transaction
type TransactionHistory struct {
	// ID is the unique identifier for this transaction record
	ID string `json:"id"`

	// WalletID identifies the wallet involved in the transaction
	WalletID string `json:"walletId"`

	// CurrencyCode specifies the wallet's currency at time of transaction
	CurrencyCode string `json:"currencyCode"`

	// InitiatorID identifies who initiated the transaction
	InitiatorID string `json:"initiatorId"`

	// ExternalReference is a reference ID from an external system
	ExternalReference string `json:"externalReference"`

	// Category classifies the type of transaction
	Category TransactionCategory `json:"category"`

	// Description provides human-readable context for the transaction
	Description string `json:"description"`

	// Amount is the principal value moved in this transaction
	Amount decimal.Decimal `json:"amount"`

	// Fee is the processing fee deducted (if any)
	Fee decimal.Decimal `json:"fee"`

	// Type indicates the direction of funds (credit/debit)
	Type TransactionType `json:"type"`

	// BalanceBefore is the wallet's available balance before the transaction
	BalanceBefore decimal.Decimal `json:"balanceBefore"`

	// BalanceAfter is the wallet's available balance after the transaction
	BalanceAfter decimal.Decimal `json:"balanceAfter"`

	// CreatedAt is when the transaction was first requested
	CreatedAt time.Time `json:"initiatedAt"`

	// CompletedAt is when the transaction was finalized
	UpdatedAt time.Time `json:"completedAt"`

	// Status indicates the final disposition of the transaction
	Status TransactionStatus `json:"status"`
}

// Transaction status transition errors
var (
	ErrInvalidStatusTransition = errors.New("invalid status transition")
	ErrTransactionCompleted    = errors.New("transaction already completed")
)

// MarkAsPending marks the transaction as pending if it's in a valid state
func (t *TransactionHistory) MarkAsPending() error {
	if t.Status == StatusCompleted || t.Status == StatusFailed {
		return ErrTransactionCompleted
	}

	t.Status = StatusPending
	t.UpdatedAt = time.Now().UTC()
	return nil
}

// MarkAsCompleted marks the transaction as successfully completed
func (t *TransactionHistory) MarkAsCompleted() error {
	// Only allow completion from pending state
	if t.Status != StatusPending {
		return ErrInvalidStatusTransition
	}

	t.Status = StatusCompleted
	t.UpdatedAt = time.Now().UTC()
	return nil
}

// MarkAsFailed marks the transaction as failed without modifying description
func (t *TransactionHistory) MarkAsFailed() error {
	// Allow failure from pending state or new transactions
	if t.Status != "" && t.Status != StatusPending {
		return ErrInvalidStatusTransition
	}

	t.Status = StatusFailed
	t.UpdatedAt = time.Now().UTC()
	return nil
}

// Revert marks a completed transaction as failed (for refunds/reversals)
func (t *TransactionHistory) Revert() error {
	if t.Status != StatusCompleted {
		return ErrInvalidStatusTransition
	}

	t.Status = StatusFailed
	t.UpdatedAt = time.Now().UTC()
	return nil
}

// CanTransitionTo checks if a status transition is valid
func (t *TransactionHistory) CanTransitionTo(newStatus TransactionStatus) bool {
	switch t.Status {
	case StatusPending:
		return newStatus == StatusCompleted || newStatus == StatusFailed
	case "":
		return newStatus == StatusPending || newStatus == StatusFailed
	default:
		return false
	}
}
